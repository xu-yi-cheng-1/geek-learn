<p>你好，我是徐昊。今天我们来聊聊测试驱动开发（Test-Driven Development，TDD）。</p><p>测试驱动开发，顾名思义，就是将软件需求转化为一组自动化测试，然后再根据测试描绘的场景，逐步实现软件功能的开发方法。</p><p>在正式开始学习TDD之前，我想通过四节课的时间，来演示如何通过TDD的方式完成一段完整的功能，让你对TDD的做法有个感性的认识。毕竟，我想很多人对TDD心存质疑，最主要还是因为不光没吃过猪肉，其实也没见过猪跑吧。</p><h2>TDD的基本原则</h2><p>为了让我的演示更有针对性，有些基本原则你需要先了解一下。TDD的创始人Kent Beck，在他的传世大作 <em><em>Test-Driven Development by Example</em></em> 的开篇中给出了TDD的基本原则：</p><ol>
<li>当且仅当存在失败的自动化测试时，才开始编写生产代码；</li>
<li>消除重复。</li>
</ol><p>不过在今时今日，我认为第二条应该改为“消除坏味道（Bad Smell）”。毕竟重复仅仅是一种坏味道，还有很多不是重复的坏味道。</p><p>那么根据TDD的基本原则，Kent Beck将开发工作分成了三步，也就是后世广为流传的测试驱动开发咒语——红/绿/重构（Red/Green/Refactoring）：</p><ol>
<li>红：编写一个失败的小测试，甚至可以是无法编译的测试；</li>
<li>绿：让这个测试快速通过，甚至不惜犯下任何罪恶；</li>
<li>重构：消除上一步中产生的所有重复（坏味道）。</li>
</ol><!-- [[[read_end]]] --><p>然而红/绿/重构循环仅仅关注单个测试这个层面，它没有回答测试从何而来。于是很多尝试采用TDD的人都卡在了第零步：我该写哪些测试？于是在2006年前后我总结了<strong>任务分解法</strong>，将任务列表作为TDD的核心要素。</p><p>任务分解法的步骤如下：</p><ol>
<li>大致构思软件被使用的方式，把握对外接口的方向；</li>
<li>大致构思功能的实现方式，划分所需的组件（Component）以及组件间的关系（所谓的架构）。当然，如果没思路，也可以不划分；</li>
<li>根据需求的功能描述拆分功能点，功能点要考虑正确路径（Happy Path）和边界条件（Sad Path）；</li>
<li>依照组件以及组件间的关系，将功能拆分到对应组件；</li>
<li>针对拆分的结果编写测试，进入红/绿/重构循环。</li>
</ol><p>那么TDD的整体工作流程如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/1f/bf/1f67315c9b8db5649d4216a5c9f3b4bf.jpg?wh=7802x4308" alt=""></p><p>请花几分钟仔细记忆这个流程，它将会在后续所有示例题目中反复出现。</p><h2>命令行参数解析</h2><p>接下来，我会通过TDD来实现命令行参数解析的功能。这个练习源自Robert C. Martin的*<em>Clean Code</em>*第十四章的一个例子。需求描述如下：</p><blockquote>
<p>我们中的大多数人都不得不时不时地解析一下命令行参数。如果我们没有一个方便的工具，那么我们就简单地处理一下传入main函数的字符串数组。有很多开源工具可以完成这个任务，但它们可能并不能完全满足我们的要求。所以我们再写一个吧。<br>
<strong>　</strong><br>
传递给程序的参数由标志和值组成。标志应该是一个字符，前面有一个减号。每个标志都应该有零个或多个与之相关的值。例如：<br>
<strong>　</strong><br>
-l -p 8080 -d /usr/logs<br>
<strong>　</strong><br>
“l”（日志）没有相关的值，它是一个布尔标志，如果存在则为true，不存在则为false。“p”（端口）有一个整数值，“d”（目录）有一个字符串值。标志后面如果存在多个值，则该标志表示一个列表：<br>
<strong>　</strong><br>
-g this is a list -d 1 2 -3 5<br>
<strong>　</strong><br>
"g"表示一个字符串列表[“this”, “is”, “a”, “list”]，“d"标志表示一个整数列表[1, 2, -3, 5]。<br>
<strong>　</strong><br>
如果参数中没有指定某个标志，那么解析器应该指定一个默认值。例如，false代表布尔值，0代表数字，”"代表字符串，[]代表列表。如果给出的参数与模式不匹配，重要的是给出一个好的错误信息，准确地解释什么是错误的。<br>
<strong>　</strong><br>
确保你的代码是可扩展的，即如何增加新的数值类型是直接和明显的。</p>
</blockquote><p>那么接下来，就让我们结合任务分解法使用TDD来完成这个需求。</p><h3>API构思与组件划分</h3><p>首先我们需要考虑，别人将以何种方式使用这段代码，也就是这段代码的整体对外接口部分。我们可以通过写测试的方式，来感受API的友好程度。</p><p><video poster="https://static001.geekbang.org/resource/image/ab/5b/ab606f3c046150a90b26678bb598ee5b.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/46c08d6d-17f90caf5dc-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/4e6602d54447415d9537063fcbac8306/38b3c51cea5642c5bb21150b04b50bba-90f924fb712fb3e3f32b0c4f4e178c2b-sd.m3u8" type="application/x-mpegURL"></video></p><p>在确定了API的形式之后，我们需要大致构思如何实现这个功能：</p><p><video poster="https://static001.geekbang.org/resource/image/ab/5b/ab606f3c046150a90b26678bb598ee5b.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/e7e4234-17f90caf383-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/867664ac3f7c485995f3d2b45d15145f/0a117251c9384e1181137a3fc9f4efe2-558919006462f63d2792f5ea02b213f3-sd.m3u8" type="application/x-mpegURL"></video></p><h3>功能分解与任务列表</h3><p>在API与实现方式有了方向之后，我们就可以根据需求的描述对功能进行分解了。这里可以先不求全面，有个大致的范围即可：</p><p><video poster="https://static001.geekbang.org/resource/image/ab/5b/ab606f3c046150a90b26678bb598ee5b.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1a0dc09f-17f90d7c38a-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/c424859d5fa548b7885373a32c1f17f9/f79e815ee8da4a689be6ba16bfac8113-1390b2f68abb0228bb763a3bd1c5c323-sd.m3u8" type="application/x-mpegURL"></video></p><h3>红/绿循环</h3><p>那么先让我们选择最简单的任务，并通过红绿循环实现它。注意其中绿的环节中，我们是如何“不惜犯下任何罪恶”的！</p><p><video poster="https://static001.geekbang.org/resource/image/ab/5b/ab606f3c046150a90b26678bb598ee5b.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/561df3f4-17f90fd3cdf-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/191d1d5a5ebe41a7b9b9e72f357d2204/c56851bd58994f5f816b962e7cd8a4a8-b90d60c69a69bf4beee1fa1b531aee39-sd.m3u8" type="application/x-mpegURL"></video></p><p>之后的两个任务，也要以同样的方式进行：</p><p><video poster="https://static001.geekbang.org/resource/image/ab/5b/ab606f3c046150a90b26678bb598ee5b.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/60d63a77-17f91011cc7-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/dcec4527c0314f33bcced1f6a6b5c60a/d707e7e6a6294a188bcd7a2aaf933f59-b24373efb9ba9efd0b08c7e293376391-sd.m3u8" type="application/x-mpegURL"></video></p><p>到此为止，我们已经完成题目中要求的第一个功能点了：</p><p><video poster="https://static001.geekbang.org/resource/image/ab/5b/ab606f3c046150a90b26678bb598ee5b.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/28952f4d-17f910f9265-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/aab94c700a0644178ad54045f967be83/e9cc3bc49128479089e75a37b21b2b0c-ca32f84d435f6f6855930945c05d94c9-sd.m3u8" type="application/x-mpegURL"></video></p><h2>小结</h2><p>至此为止，我们实现了第一个主要功能：支持由三个不同类型组合而成的命令行参数的解析。</p><p>可以看到，我们在进入TDD的红/绿/重构循环之前做了许多准备工作。我们先花费2～3分钟设计了API，2～3分钟构思了实现策略，然后在任务分解上花费了更多的时间，差不多有5分钟。到目前为止，编码的时间大约是15分钟。</p><p>这并不像很多原教旨主义TDD实践者所推崇的那样，完全依赖重构而不去做设计。然而以我二十年来实践TDD的经验来看，<strong>理解需求，并通过测试构成高效的节奏，是有效实施TDD的前提。特别是在有其他团队成员的情况下（结对或项目组），更需要如此</strong>。希望你能从今天起，更加注重“TDD的准备工作”。</p><p>下节课，我们将在这段代码的基础上开始重构，然后再逐步完成后续的开发。</p><h2>思考题</h2><p>如果在思考实现策略的时候，我们选择了其他的实现方式，那么任务分解会有什么不同？</p><p>如果你在学习过程中还有什么问题或想法，欢迎加入<a href="https://jinshuju.net/f/zvOavT">读者交流群</a>。最后，也欢迎把你学习这节课的代码与体会分享在留言区，我们下节课再见！</p>
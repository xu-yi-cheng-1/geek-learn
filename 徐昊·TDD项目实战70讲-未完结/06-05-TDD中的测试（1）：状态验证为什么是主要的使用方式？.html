<p>你好，我是徐昊。从这节课开始我们来正式学习测试驱动开发（Test-Driven Development，TDD）。</p><p>通过前面四节课的演示，相信你对测试驱动开发已经有了一定的感性认识。测试作为整个流程的驱动力，无论是在开发还是重构过程中都起到了重要作用。我想你对这一点一定有了比较深刻的印象。那么从今天开始，我们就来学习如何编写测试。</p><h2>测试的基本结构</h2><p>无论使用什么样的测试框架，每个测试都由四个依次执行的阶段组成：初始化（SetUp）、执行测试（Exercise）、验证结果（Verify）和复原（Teardown）。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/bf/20/bf61378a8554c9331102957fc4bbc220.jpg?wh=6369x3633" alt=""></p><p>需要说明一下的是，测试上下文（Test Context）在很多文献中被称作测试夹具（Test Fixture）。</p><p>夹具是个隐喻，是木工或者其他制造过程中，用以固定待加工工件的器具（上图中，棕色部分看起来是不是“夹”住了待测系统）。当然，这种拿一个生僻概念来隐喻另一个生僻概念的操作，也是很迷了。我要不是因为做吉他学习了木工，也不明白为什么要叫Fixture。抛开这个隐喻，直接称作测试上下文其实就简单易懂多了。</p><p>再多说一句，如果使用<a href="https://en.wikipedia.org/wiki/Framework_for_integrated_test">Fit</a>系自动化测试工具（Fit、Fitness，甚至concordion、selenium），Fixture则表示驱动待测系统的交互接口，也叫Driver。这也是为啥，Selenium后来改叫WebDriver的原因。</p><!-- [[[read_end]]] --><p>言归正传，这四个阶段的主要作用是：</p><ul>
<li><strong>初始化。</strong>主要是设置测试上下文，从而使待测系统（System Under Test）处于可测试的状态。例如，对于需要操作数据库的后台系统，测试上下文包含了已经灌注测试数据的测试用数据库，并将其与待测系统连接。</li>
<li><strong>执行测试。</strong>就是按照测试脚本的描述与待测系统互动。例如，按照功能描述，通过API对系统进行相应的操作。</li>
<li><strong>验证结果。</strong>就是验证待测系统是否处于我们期待的状态中。例如，经过测试，数据库中的业务数据是否发生了期待中的改变。</li>
<li><strong>复原。</strong>就是将测试上下文、待测系统复原回测试之前的状态，或者消除测试对于待测系统的副作用。例如，删除测试数据中的数据（通常是通过事务回滚）。</li>
</ul><p>接下来，看一看前四节课演示的测试中，这四步都是如何实现的：</p><h5><video poster="https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/31a7560f-17fa5eb9404-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/67a60446ed6744cc97d5ed8401e16aa4/2cf13f904218489f960934637266830a-1697ba1c28a3f9b5706adfb183a14bb5-sd.m3u8" type="application/x-mpegURL"></video></h5><p>需要说明的是，在参数解析这个例子中，待测系统是命令行参数解析的Java类库（Java Library），并不涉及数据库、消息中间件、三方服务等进程外组件，也没有进程内三方组件依赖（比如OSGi Runtime、Servlet容器），因而测试上下文相对简单。而对于存在进程外组件或进程内三方组件依赖的场景，<strong>测试上下文的设置将直接影响编写测试的难度，以及维护测试的成本</strong>。</p><p>在测试的四个步骤中，<strong>验证结果是最核心的一步，也是最核心的技术</strong>。验证结果有两种方式：状态验证（State Verification）和行为验证（Behavior Verification）。</p><h2>状态验证</h2><p>状态验证是指在与待测系统交互后，通过比对测试上下文与待测系统的状态变化，判断待测系统是否满足需求的验证方式。在前四节课的演示中，全部测试都采用了状态验证的方式：</p><p><video poster="https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4a2350af-17fa5eb9139-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/3c0f0a4d7e9441d3be9e259830442602/e638a956bdf84853b5f2ec805dd74ba3-23e485db3f6f5c7fab0c8e3c29e4f593-sd.m3u8" type="application/x-mpegURL"></video></p><p>状态验证是一种<strong>黑盒验证</strong>，它将<strong>测试上下文与待测系统当作一个整体</strong>。当待测系统不存在内部状态，而通过作用于依赖组件（Depended On Component）达成功能的时候，我们会从依赖组件中获取状态，以验证待测系统。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/69/03/6993505dc7a6c2352fbfae97424ff203.jpg?wh=6341x3495" alt=""></p><p>让我们回忆一下开篇词中“测试应用”的例子。其中StudentRepository自身不具有内部状态，而是通过EntityManager操纵数据库来完成功能。如果以TDD的方式来构造对于StudentRepository的测试，就会是这样的：</p><p><video poster="https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/644837-17fabec9ebf-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/3b4ffb69d4d64780a12215ecfea3ee6c/153f585705df422db144d1f6fd0f9ddd-14f125530d813582306920b056e87f9c-sd.m3u8" type="application/x-mpegURL"></video></p><p>状态验证的一个难点是复原测试上下文，消除因执行测试造成的状态累积。如果待测系统是类库，一般问题不大，重新构造新的对象实例就行了。</p><p>而对于测试环境中存在进程外组件的情况，问题就要复杂一些了。在这种情况下，<strong>增量状态验证</strong>（Delta Verification）是一种有效的手段：</p><p><video poster="https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4e88cccc-17fa5eb8e43-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/c0969fc04a8047a2bcbaa948971d9202/75f559efb0b24ed080702b84e4211bc6-e0f19b6f89c229780d5dee1eeeaff273-sd.m3u8" type="application/x-mpegURL"></video></p><p>当然，在这个例子里，在每一个测试复原时，都使用了“drop-and-create”来清除数据库中的数据，从而消除状态累积。但如果因为种种原因（比如测试数据量很大），使得每次清除测试数据都变得不现实时，就可以使用增量状态验证来降低状态累积的影响。</p><h2>小结</h2><p>今天我们介绍了测试的基本结构，这个结构也叫<strong>四阶段测试（Four-Phase Test）。</strong>四阶段测试作为测试的基本模型，存在于各种测试框架中。而对于四阶段不同的组织方式，也构成了不同的测试编写风格，比如RSpec、ScalaTest等框架提供的BDD风格。不过无论是哪种风格，都不影响我们按照四阶段来理解测试的执行。</p><p>在四阶段中，验证结果是最核心的一步。它主要有状态验证和行为验证两种方式，其中状态验证需要大量使用<strong>断言方法</strong>（Assertation Method）来判断状态。同样，每个框架都提供了大量的断言方法，请参看具体框架的文档。</p><p>虽然状态验证是TDD中最重要的验证方法，但在某些情况下，我们仍然需要使用另一种验证方式——行为验证。这个我们将在下节课进行详细讲解。</p><h2>思考题</h2><p>为什么TDD中主要使用状态验证来验证测试的结果？</p><p><strong>编辑来信</strong>：</p><blockquote>
<p>TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了<strong>“TDD专栏首发·代码评点”</strong>活动。<br>
<strong>　</strong><br>
在第一个实战项目结束后，我们会根据你提交的<a href="https://jinshuju.net/f/TvdN15">学习反馈</a>，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。<br>
<strong>　</strong><br>
划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。<br>
<strong>　</strong><br>
最后，希望我们都能好好学习，更上层楼！</p>
</blockquote>
<p>你好，我是徐昊。今天我们来继续学习测试驱动开发中的测试。</p><p>上节课我们介绍了测试的基础结构——四阶段测试。也就是将每个测试都看作四个依次执行的阶段：初始化、执行测试、验证结果和复原。并且，我们着重介绍了该如何使用状态验证来验证测试的结果。那么这节课，我们将介绍另一种验证方式——行为验证。以及为什么你应该尽量避免使用它。</p><h2>验证结果——行为验证</h2><p>行为验证是指通过待测系统与依赖组件（Depended On Component）的交互，来判断待测系统是否满足需求的验证方式。其验证方式如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/dc/81/dc38c422387a97b92e9f4247e9848181.jpg?wh=6104x3295" alt=""></p><p>行为验证背后的逻辑是，状态的改变是由交互引起的。如果所有的交互都正确，那么就可以<strong>推断</strong>最终的状态也不会错。例如，对于如下的代码：</p><pre><code>interface Counter {
  void increase(); 
}

class SUT {
  public void action(Counter counter) {
    counter.increase();
  }
}
</code></pre><p>功能需求是SUT的action方法调用计数器Counter使其计数增加。按照状态验证，我们需要从Counter中获取内部计数，然后判断在执行测试前后，计数是否增加。</p><p>而对于行为验证，因为计数增加与否只在于是否调用了increase方法。那么如果SUT调用了increase方法，我们就可以<strong>推测</strong>Counter的计数也必然增加了。于是，我们可以将对于读数增加的验证，转化为对于increase方法调用的验证：如果increase方法被调用了，那么我们可以<strong>推测</strong>SUT是满足功能需求的。状态验<strong>果</strong>，行为推<strong>因</strong>。</p><!-- [[[read_end]]] --><p>那么要怎么使用行为验证呢？让我们将命令行参数解析中的测试，改写成行为验证：</p><p><video poster="https://static001.geekbang.org/resource/image/76/05/762849d86939179229876ec4da039b05.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2726ff4a-17fabec9a15-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/2764dcdd5eaa482d8a01507a48051785/ce6f2689aba14545b6d16da1f833680c-dc47b8695a2f26d50506ad16b063fb49-sd.m3u8" type="application/x-mpegURL"></video></p><p>对比状态验证和行为验证，在测试上下文中，我们引入了<strong>测试替身</strong>（Test Double）来作为测试上下文中的依赖组件，然后使用测试替身的验证方法代替了测试框架提供的断言方法。具体到这个例子中，我们使用Mockito API中的verify替换了JUnit API中的assert方法。</p><p>在参数解析的例子中，行为验证和状态验证几乎没什么差别。如果硬要说的话，状态验证稍稍容易懂一些。那么我们为什么要使用行为验证呢？</p><h2>旨在降低测试成本</h2><p>在TDD社区中，行为验证主要是为了降低测试成本。再让我们看一下开篇词中“测试应用”的例子，如果换做行为测试的话，我们就不需要使用实际的数据库了：</p><p><video poster="https://static001.geekbang.org/resource/image/76/05/762849d86939179229876ec4da039b05.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/198b1c85-17fa5eb8aac-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/2b3b760c03f1442a8844d4cec06b2dc0/bdee8c7ec3ca40739e1df588def1125d-60b4ee524f8bc90faf5c10e81fce2824-sd.m3u8" type="application/x-mpegURL"></video></p><p>对于类似于数据库这样的进程外组件，我们都可以通过类似的手段加以处理。也就是说，明确指明待测系统如何与进程外组件交互，并以此为基准，验证待测组件的行为是否满足需求。类似的场景还有很多，比如三方支付服务、消息队列（Message Queue）或者其他微服务等等。</p><p>除了进程外组件，还有一种情况是进程内组件的状态难以获得。最典型的例子就是具有图形界面（GUI，Graphics User Interface）的应用，比如Android App、Eclipse RCP等等。在有GUI的情况下，我们需要测试视图（View）与模型（Model）的状态一致。通常视图中的状态难以获取，或者获取成本极高（比如我就有过很多次需要从头写GUI TestDriver的情况）。在这种情况下，也可以使用行为验证来代替状态验证，完成测试。</p><h2>对TDD用处不大</h2><p>无可否认，行为验证是一种有用的技巧，但是<strong>对TDD用处不大</strong>。在开篇词“测试应用”的例子中，我们是改写的已有测试。而如果重头来一遍的话，你就会发现问题所在了：</p><p><video poster="https://static001.geekbang.org/resource/image/76/05/762849d86939179229876ec4da039b05.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/451e1d6a-17fa5eb8749-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/866fabe8829e4eb08b7827f8616d0579/0bef74641ede418489c934fb1107abd3-f1d82ce1e5290c483fabee08d78aecd4-sd.m3u8" type="application/x-mpegURL"></video></p><p>是不是感觉把实现代码先在测试中写了一遍，然后又搬回到生产代码中去了？除了多写了一遍实现代码，到底有什么好处？怎么有一种脱了裤子放屁的感觉？</p><p>除了直观的体验很差之外，行为验证的逻辑也与TDD的核心逻辑冲突。</p><p>上节课我们讲过，状态验证是将测试上下文与待测系统当作一个整体的黑盒验证，而行为验证就是将它们看作分离组件的<strong>白盒验证。</strong></p><p>它的逻辑是<strong>通过测试功能是如何实现的，来推断结果是否正确</strong>。换句话说，行为验证本身并<strong>不能验证功能是否正确</strong>，而只能验证<strong>功能是否按照某种方式实现</strong>。如果按照某种方式实现，那么就可以<strong>推测</strong>出功能是正确的。</p><p><strong>这与TDD的核心逻辑就冲突了</strong>。在TDD的红/绿/重构中，<strong>重构</strong>要求在功能不变的前提下，改变实现方式。而对于行为验证而言，<strong>实现方式改变就是功能改变</strong>。因而重构就无法进行！需要<strong>重写！</strong>也就是说，<strong>行为验证会阻碍TDD的进行</strong>。</p><p>仍然以“测试应用”为例，如果我们将JPQL的实现方式改为Criteria API，那么行为验证就会失败，而状态验证则不会：</p><p><video poster="https://static001.geekbang.org/resource/image/76/05/762849d86939179229876ec4da039b05.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4156fcd7-17fa5eb8464-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/6bba8b00b805491d9b528d5ddb02d6fb/a1feeaa8b1284cda995bf24e7723fcdc-9a3d7f7dfc682a1ebddbbc9d0b52a082-sd.m3u8" type="application/x-mpegURL"></video></p><h2>丧失测试的有效性</h2><p>除去与TDD的逻辑冲突之外，行为验证还可能会<strong>丧失测试的有效性</strong>。特别是在依赖复杂的框架或是进程外组件的时候。</p><p>还是“测试应用”的例子。在这个例子中，领域模型存取的成功并不仅仅依赖于代码，还依赖于JPA的元数据与配置。那么，仅仅通过与EntityManager的交互，并无法验证元数据的配置是否正确，类似的还有查询语句本身的正确性等等。</p><p><video poster="https://static001.geekbang.org/resource/image/76/05/762849d86939179229876ec4da039b05.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/c872036-17fabf3d55a-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/46955895c660486b9af6ab9f7d8ce32c/1b1981ef10fe428d923f314920698463-ecae84519c7dca562e39144fae504710-sd.m3u8" type="application/x-mpegURL"></video></p><p>虽然行为验证的主要目的是降低测试成本，但如果丧失了测试的有效性，那么成本再低也是无意义的。</p><h2>小结</h2><p>今天我们介绍了行为验证，以及如何通过行为验证<strong>推测</strong>待测系统是否满足功能需求。虽然在特定场景下，行为验证是非常有用的<strong>测试技术，</strong>但它并不合适作为TDD的默认验证方式。为了保证TDD中的红/绿/重构循环，我们应该尽量使用状态验证。</p><p>至于降低测试成本，在云时代的今天我们有了其他的选择（比如Test Container、Mountebanke等进程外测试替身），并不一定非要使用行为验证。</p><p>需要提醒的是，虽然行为验证会大量使用测试替身技术，但并不是所有的测试替身都是行为验证。Martin Folwer在他的名篇<a href="https://martinfowler.com/articles/mocksArentStubs.html">《Mock不是Stub》</a>中，对于不同的测试替身给予了充分的说明。</p><h2>思考题</h2><p>虽然我们反复提醒，行为验证不适合作为TDD的默认验证方式，那么在哪些特定情况下，行为验证即不会影响重构又能降低测试成本呢？</p><p><strong>编辑来信</strong>：</p><blockquote>
<p>TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了<strong>“TDD专栏首发·代码评点”</strong>活动。<br>
<strong>　</strong><br>
在第一个实战项目结束后，我们会根据你提交的<a href="https://jinshuju.net/f/TvdN15">学习反馈</a>，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。<br>
<strong>　</strong><br>
划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。<br>
<strong>　</strong><br>
最后，希望我们都能好好学习，更上层楼！</p>
</blockquote>
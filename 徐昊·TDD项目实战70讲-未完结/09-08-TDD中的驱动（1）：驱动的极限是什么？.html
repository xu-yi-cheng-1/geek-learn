<p>你好，我是徐昊。从今天开始，我们来讨论一下测试驱动开发中的驱动是什么意思。</p><p>在上节课，我们讨论了测试驱动中测试的性质。它们不是“单元测试”，而是不同粒度的功能测试。或者如我建议的那样，你可以叫它们“单元级别功能测试”。那么这些单元级别功能测试将会如何驱动我们的开发呢？今天我们就来讨论一下这个问题。</p><h2>如果当初我们那么做了</h2><p><a href="https://time.geekbang.org/column/article/496699">上节课</a>我们讲到，TDD中测试针对的粒度是独立的功能上下文或变化点。测试验证功能上下文或变化点符合功能需求。</p><p>对于相同的功能，如果我们划分的功能上下文不同，会有什么结果呢？回看之前的TDD演示，在<a href="https://time.geekbang.org/column/article/494207">第一讲</a>中，我们讨论了三种实现方式：</p><ol>
<li>从给定的参数列表中寻找对应选项，并根据选项类型读取参数；</li>
<li>将参数列表按照选项，分割成由选项名称和参数组成的数组；</li>
<li>将参数列表按照选项，分解成由选项名称和参数组成的映射。</li>
</ol><p>这三种选择实际上就划分了不同的<strong>功能上下文</strong>。当时出于实现方式复杂度的考虑，我选择了第一种实现方式。即，从功能上下文的角度考虑，也就是从API视角出发，将全部功能当作一个上下文。那么如果我们当时选择了其他的实现方式，会如何呢？请看接下来的视频演示。</p><p><video poster="https://media001.geekbang.org/f807a6f207324c28907c7b0474ae8075/snapshots/7b5b659f1c0345458d3928426d16225c-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1f163e47-17fba7f8bd5-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/60cf3888ce794c338ad57ce07afe5823/be65755fe7f24ba6809f60c9484facea-f01ea31cae424dcd363a9d6a44cf1b99-sd.m3u8" type="application/x-mpegURL"></video></p><p>好，到此为止，通过红/绿循环，我们实现了参数分割的功能。剩下的部分，其实与我们之前展示的相差不多。我稍微演示一两个测试，其他的你可以自行操作。</p><!-- [[[read_end]]] --><p><video poster="https://media001.geekbang.org/da25ec3bd13b4446b80af8995af08e44/snapshots/2a0f5ccbb234408e88bb95b33eb868e4-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/167bb9c3-17fba7f8921-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/96b36b1a4dce495f8cae7cb1470ca41d/5a8b09d791c14d25a37802e66112ad4a-a1bfb084fbe5df8fd524dad2420247cb-sd.m3u8" type="application/x-mpegURL"></video></p><p>可以发现，对比第一次我们做的实现，不同的<strong>实现策略</strong>，隐含着不同的<strong>功能上下文</strong>划分。针对不同的功能上下文，我们编写对应的单元级别功能测试来验证其功能。在这些单元级别功能测试的指引下，我们逐步完成了软件的功能。也就是说，功能上下文的划分，指引我们编写测试；在测试的驱动下，我们逐步完成功能上下文的实现。</p><p>从这里，我们似乎可以窥探到测试驱动开发的核心要点：单元级别功能测试能够驱动其对应单元（功能上下文或变化点）的<strong>外在功能需求</strong>。而对于<strong>对应单元之内功能</strong>的实现，测试就没有办法了。</p><p>以上面演示的视频为例，我们需要将参数列表进行分解。但参数列表的分解是Args.parse内部实现的方式。当我们从功能测试的角度测试Args.parse时，是无法得知Args.parse是如何处理参数列表的。所以，无论是这节课的实现方式，还是<a href="https://time.geekbang.org/column/article/494207">第一讲</a>里的实现方式。从Args.parse这个<strong>功能上下文来看</strong>，测试是<strong>极端类似</strong>的。</p><p>如果我们要驱动单元内的功能实现，该怎么办呢？那么就需要将这个单元对应的功能上下文，分解为更小的上下文，并将功能需求在这个上下文中加以分解。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/de/fc/de596yycd58a77a8a005773aef84c2fc.jpg?wh=5614x2707" alt=""></p><p>比如上面演示的视频中，Args.parse是一个大的功能上下文。按照我们的实现思路，我们将它分解成了一个小的功能上下文：将参数列表分解为映射。那么我们可以将参数列表分解放入另外一个单元（Args.toMap)，对它进行测试，从而驱动它的实现。</p><p>也就是说，单元级别功能测试<strong>无法驱动</strong>小于其测试单元的功能需求，也<strong>无法驱动</strong>单元内的实现方式，需要进一步拆分功能上下文才可以。而指引功能上下文拆分的方式有很多，比如有不同的实现思路、架构等。</p><h2>TDD的极限</h2><p>曾经有些人希望通过构造难以用测试驱动出实现的需求，来证明TDD不是一种有效的开发方法。对于这些人，我都懒得回应。</p><p>第一，是因为这样的需求一点儿都不难构造；第二，TDD并没有宣称它是所有开发问题的答案，所以找到一个反例又能说明什么呢？第三，TDD的效用在于将研发过程工程化。那么无法通过TDD有效实现需求，也只意味着这类问题不能有效工程化而已。排除一个错误答案，并不代表能找到正确的答案。</p><p>根据我们<a href="https://time.geekbang.org/column/article/496699">上一节</a>的讨论，让TDD丧失驱动力最简单的办法，<strong>就是指明某个单元内的实现细节</strong>。比如，使用<strong>冒泡法</strong>对数组进行排序。因为从功能角度来说，冒泡法还是快排序，是没有差别的：</p><pre><code>@Test
public void should_sort_by_bubble_sort() {
  assertArrayEquals(new int[] {1, 2, 3}, bubbleSort(3, 1, 2));
}

@Test
public void should_sort_by_bubble_sort() {
  assertArrayEquals(new int[] {1, 2, 3}, quickSort(3, 1, 2));
}
</code></pre><p>如果我们需要在测试中体现不同排序算法的差异，以驱动不同的实现，那么就需要改用行为验证的方。请观看接下来的视频演示：</p><p><video poster="https://media001.geekbang.org/5eccfe77a2084038a2fb38e26a60c079/snapshots/064bfcb5b90d4ef08f29884589ac1e25-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/304f7ffa-17fba7f856c-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/2ad4c399cb2744e5aefec0792f180388/a93173d2fd3442689a71c5d3c7a0ab3f-2c94feeb50bdd99d31356de2d3c04503-sd.m3u8" type="application/x-mpegURL"></video></p><p>至此，我们可以明白，<strong>测试驱动开发的主要关注点在于功能在单元（模块）间的分配，而对于模块内怎么实现，需要你有自己的想法</strong>。当然Kent Beck说得更直接：TDD可以提高效率，但不能避免愚蠢。</p><h2>如果真的不知道怎么实现</h2><p>如果真的不知道该怎么实现，要怎么办呢？那么TDD仍然可以帮你提高效率。就是这么神奇！</p><p>还是以ArgsTest为例，如果我就是不知道参数分解这一步到底要怎么实现，那么我能怎么办呢？</p><p><video poster="https://media001.geekbang.org/41d6d1b2372a49ac8f1b9cf37182d1da/snapshots/fb78a5d77d734907a66e09fe12c3acc6-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/407f791d-17fba7f81cf-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/2b7ca0c20b724909a2933cd77bed3cc7/a05df95218ce47e494f6e6c2758f5a3c-5ace9f81320901ff4454dcc53e3eb235-sd.m3u8" type="application/x-mpegURL"></video></p><p>正如视频中演示的，就算你真的不知道某个关键的功能要如何实现，只要你能列出对于这个单元的期待，<strong>那么你仍然可以完成其余功能，然后再找人帮忙！</strong></p><p>只不过此时，你就算找人帮忙，对于这个模块的输入输出也已经了然于胸。当然，你还可以写一组测试，验证别人帮你写的代码是否真的可以完成你想要的功能。甚至你还可以带着测试代码到Stack Overflow上去求助，肯定会有意想不到的收获。</p><h2>小结</h2><p>这节课我们讨论了测试驱动开发到底驱动了什么：功能在单元（模块）间的分配。我们也讲了，测试驱动开发在什么地方会失去驱动力：单元（模块）内的实现方式。</p><p>那么很有意思的事就来了，从“驱动”的角度来说，TDD实际上并不是一种编码技术（Coding Technique），它无法帮助实现你不会写的代码，你必须要知道如何实现这些功能；但是一旦你明确了要实现的功能，并且知道要怎么实现，TDD可以帮助你更好地将功能放置到不同的单元。也就是说，<strong>TDD“驱动”的是架构，因而实际是一种架构技术</strong>。</p><p>是的，这正是我们讲的编码架构师（Coding Architect），也是真正的实干型而非PPT型架构师（当然你可以省略地讲，这是真正的架构师）。这也是为什么TDD也被看作Test Driven Design。当然，我觉得Test Driven Development其实描述得更全面。</p><h2>思考题</h2><p>请从架构的角度出发，思考红/绿/重构循环，分别发挥了什么作用？</p><p><strong>编辑来信</strong>：</p><blockquote>
<p>TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了<strong>“TDD专栏首发·代码评点”</strong>活动。<br>
<strong>　</strong><br>
在第一个实战项目结束后，我们会根据你提交的<a href="https://jinshuju.net/f/TvdN15">学习反馈</a>，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。<br>
<strong>　</strong><br>
划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。<br>
<strong>　</strong><br>
最后，希望我们都能好好学习，更上层楼！</p>
</blockquote>
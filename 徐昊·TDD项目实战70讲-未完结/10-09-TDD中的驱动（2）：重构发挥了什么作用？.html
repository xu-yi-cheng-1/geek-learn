<p>你好，我是徐昊。今天我们来继续讨论测试驱动开发中的驱动。</p><p>在上节课，我们讲了单元级别功能测试能够驱动其对应单元（功能上下文或变化点）的外在功能需求。但是当对应单元过大时，会带来一系列麻烦（比如测试构造困难、问题定位不准确等），那么就需要将对应单元的功能上下文继续分解成更小的粒度，然后通过测试来驱动实现。</p><p>从“驱动”的角度讲，TDD并不是一种编码技术，它无法驱动你写出你不会实现的代码。<strong>TDD是一种架构技术</strong>，它能通过测试与重构，驱动单元的划分以及功能的归属，因而是一种更为落地的架构软件的方式。</p><p>在TDD中，重构是和测试一样重要的驱动力，驱使我们得到更好的架构和更清晰的代码结构。因而熟练掌握几种常用的重构手法，也是十分必要的。</p><h2>语义化的查找替换（Semantic Find and Replace）</h2><p>首先要介绍的重构手法是提取方法（Extract Method）和内联方法（Inline Method）。这是最重要的两种重构手法，它们相当于查找（Find）/替换（Replace）。所不同的是，这种查找替换是语义化的：在不破坏现在代码结构的前提下，完成查找替换。视频演示如下：</p><p><video poster="https://media001.geekbang.org/8e3a9db8fa0f480a82a599688a732bc9/snapshots/987c2732aea746ab9e96e08ca9affee5-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/355cf44-17fb9ee3d28-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/ea5a7b9acc9b4ca48db803f85e18e006/6f5c1a8793d54bd887d5ff56012d2785-495a909ecd303d452d6c0f965ecfb89d-sd.m3u8" type="application/x-mpegURL"></video></p><p>正如视频中所展示的，这个手法是将需要修改的代码提取到新方法中。在新方法内完成要做的修改，再通过内联方法在所有调用这个新方法的地方完成修改。我们需要将这两种手法看作修改代码的基本方式。</p><!-- [[[read_end]]] --><h2>通过提取/合并单元进行重架构（Extract and Merge Units）</h2><p>在提取方法的基础上，我们可以进一步将提取出的行为从当前对象中分离出去，也就是提取对象（Extract Object）。视频演示如下：</p><p><video poster="https://media001.geekbang.org/35a101792fa64959b5a91b269f1cf58b/snapshots/561c09e9cc9b44aab77ff6f7452b9377-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4e9b9ab6-17fb9ee395e-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/1fe6dfaab68b47568d9bac7a66de4715/d8d328a313274b3083ed23eea43b0041-5991f7bf5cfa04f18c2df25b20e35616-sd.m3u8" type="application/x-mpegURL"></video></p><p>一旦提取出对象，我们就能通过类内字段（Field）、参数（Parameter）等方式，不再直接引用当前对象上下文，从而将其与当前对象上下文分离。对应地，我们可以使用的重构手法有引入字段（Introduce Field）、引入参数（Introduce Parameter）等。视频演示如下：</p><p><video poster="https://media001.geekbang.org/9bacb9fbc74248b6970f93ea1061ea4d/snapshots/baf91fd4d01c4d03a72770ae28b9bca5-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/3c167398-17fb9ee3622-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/8643c29f7f1444788f2277a2b6a40442/630430e2e1684bb2bc71612bc8626310-6df9730b1ce5fd723f4cf8aabc2879de-sd.m3u8" type="application/x-mpegURL"></video></p><p>通过这些重构手法，我们对类结构进行了调整，也就是<strong>模块的重划分</strong>和<strong>功能的重分配</strong>。都不用四舍五入，这就是对已有代码的<strong>重架构</strong>（Re-architecture）。</p><p>当然，能分自然能合。如果模块结构不合理，那么完全可以通过刚才介绍的语义化的查找替换来完成单元的合并。视频演示如下：</p><p><video poster="https://media001.geekbang.org/15260fdac62d48c3ac4dd1823a802dc8/snapshots/616866cc80c9413fa490dbc58cb3c663-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/5e6f05ea-17fb9ee3217-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/dfb53bab8bb348e284cd9837d25697f3/1e4d76c26941477e89fa15fe6e36afc7-e4db8274b047153fdd45813ae990dd59-sd.m3u8" type="application/x-mpegURL"></video></p><p>到此为止，我们介绍了重构的基本手法。通过这一组操作，我们可以完成对于代码的修改，以及对于架构的调整。这些手法如此基础，<strong>应该被看作修改代码的基本功，而不是重构：</strong>谈不上什么消除坏味道，就是高效修改代码而已。</p><h2>使用多态替换条件</h2><p>组合使用这些基础手法，我们就可以进行一些更大规模的重构。比如我们之前在Args例子中展示过的使用多态替换条件分支。现在请你重新看一遍<a href="http://time.geekbang.org/column/article/494212">第二讲</a>中的前两段视频。</p><p><video poster="https://static001.geekbang.org/resource/image/c3/a2/c3f7a5d53abb98f63d4e37c24ed023a2.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/3373f638-17f91553b08-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/6dea22b14c3b4caab62466461955821c/039596878d2540718e32ca87786130f7-77887e32b1a08347a96fc82fe56a0e50-sd.m3u8" type="application/x-mpegURL"></video></p><p><video poster="https://static001.geekbang.org/resource/image/c3/a2/c3f7a5d53abb98f63d4e37c24ed023a2.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/e47c810-17f916ecdb2-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/c68b68b21dd84319931b5e9db355a045/4757539d9a1b4d0793c751c6e1af4486-7f004010fed712c2a8cca7c455fc2879-sd.m3u8" type="application/x-mpegURL"></video></p><p>这两段视频中展示的重构与刚才介绍的几种手法不同，我们消除了坏味道并强化了开放封闭原则（Open-Closed Principle，OCP）：新增的类型解析不需要修改Args的实现，可以通过扩展OptionParser接口实现。<strong>对修改封闭，对扩展开放</strong>。</p><p>这种架构改进方法叫做<strong>重构到模式</strong>（Refactoring to Patterns），即：将架构上的坏味道替换为设计模式（Design Pattern）。这是一种更有效的架构软件的方法，用公认的好设计（模式）替换了公认的不好的设计（坏味道），还能满足功能的需求，必然能是更好的架构（而不用虚无缥缈地归结于“品味”或“经验”）。</p><p>对于TDD，行业中存在这样一种困惑：从功能测试出发，逐步完成软件开发，这或许没问题。但架构怎么办？实际上，红/绿/重构循环中的重构就是解决架构问题的。只不过架构并不是<strong>预先设计的</strong>（Upfront Design），而是在完成功能的前提下<strong>演进而来的，因而也称演进式设计</strong>（Evlutionary Design）。</p><p>通过重构到模式演进式地获得架构，是一种实效主义编码架构风格（Pragmatic Coding Architect）。这是习惯了预先设计的PPT架构师们不曾体验过的经历，因而不被理解也是很正常的了。</p><p>顺便说一句，Joshua Kerievsky在2004年写过一本书，就叫 <em>_Refactoring to Patterns</em>_ 。这本书的价值远被低估了，是关于软件架构非常重要的著作！</p><h2>小结</h2><p>这节课我们介绍了四种基本的重构手法，分别是提取方法、内联方法、引入参数和引入字段。这几种手法应该被看作修改代码的基本功。</p><p>此外，如果无法借助自动化重构工具高效修改代码，那么TDD带来的效率将会大打折扣。而无法支持这几个核心手法的IDE，也不足以支撑TDD的实施。</p><p>我们还展示了通过组合使用这些基本手法，来完成较大规模重构的例子。并简略介绍了TDD原生的架构方法，也就是<strong>重构到模式</strong>。对于常见的架构上的坏味道，我们都可以通过某些模式将其消除，从而得到更好的架构。</p><h2>思考题</h2><p>除了重构之外，如果架构预先设计好了，那么要怎么使用TDD？</p><p><strong>编辑来信</strong>：</p><blockquote>
<p>TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了<strong>“代码评点”</strong>活动。<br>
<strong>　</strong><br>
在第一个实战项目结束后，我们会根据你提交的<a href="https://jinshuju.net/f/TvdN15">学习反馈</a>，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。<br>
<strong>　</strong><br>
划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。<br>
<strong>　</strong><br>
最后，希望我们都能好好学习，更上层楼！</p>
</blockquote>